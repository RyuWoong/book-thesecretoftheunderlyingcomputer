- 프로그래밍 언어는 어떻게 만들었을까?
- 실행 파일은 왜 실행될 수 있을까?
- 실행 파일은 어떤 형태로 어떻게 실행될까?
- 실행되고 나면 어떤 형태를 갖추게 될까?
- 어떻게 하면 더 효율적으로 실행할 수 있을까?

## Chapter 1. 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

### 1.1. 여러분이 프로그래밍 언어를 발명한다면?

- 어셈블리어
    - add → 010101
- 컴파일러
    - 리프 노드부터 기계 명령어로 번역 → 부모 노드에 적용 → 타고 올라가서 전체 트리를 완성
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6ac5d8a4-16ad-4cf8-84bb-2f89d8c04c9a/07caf949-1ddc-45ff-a5c0-eaa08d0aa20d/Untitled.png)
    
- 인터프리터 interpreter
    - 실행코드를 해석해 표준 명령어로 전환

### 1.2 컴파일러는 어떻게 작동하는 것일까?

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6ac5d8a4-16ad-4cf8-84bb-2f89d8c04c9a/47e740ee-b3d2-4c33-bf4d-a0a7d94a004c/Untitled.png)

- 컴파일러
    - 고수준 언어를 저수준 언어로 번역하는 프로그램
    1. 컴파일러가 소스 코드를 받음
    2. 어휘 분석(lexical analysis)
        - 각 항목을 잘게 쪼개서 토큰(각 항목에 추가로 정보를 결합한 것) 추출하는 과정
    3. 해석(parsing)
        - 토큰을 하나하나 처리
    4. 구문 분석
        - 해석을 통해 구문 트리를 생성하는 전체 과정
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6ac5d8a4-16ad-4cf8-84bb-2f89d8c04c9a/5d936c84-a64c-4ea2-b090-d9454a1b9a68/Untitled.png)
        
    5. 의미 분석(semantic analysis)
        - 구문 트리에 이상이 없는지, 컴파일 오류가 없는지 확인.
        - 의미 분석이 끝나면 중간 코드(Intermediate Representation Code, IR Code) 생성
    6. 코드 생성
        - 중간 코드 → 어셈블리어 코드 변환
        - 어셈블리어 코드 → 기계 명령어 변환
    - 대상 파일 (object file)
        - .o 확장자를 가지는 파일
        - 소스 코드 조각 = 전체 소스 코드 파일인 code.c의 일부분 일때, 컴파일 과정 거쳐 생성된 기계 명령어 데이터 code.o 파일에 저장
        - 모든 소스 파일에는 각각의 대상 파일 존재
- 링커 Linker
    - 나누어진 대상 파일을 하나의 실행 파일로 합쳐주는 프로그램

### 1.3 링커의 말할 수 없는 비밀

- 다른 모듈의 programing interface OR 변수 참조
    - 서로 다른 대상 파일(object file)들이 서로를 참조.
    - 한 모듈이 구현한 연결 리스트를 다른 모듈에서 사용시 둘 사이 **종속성이 있다**고 표현
    - 이러한 참조에 대한 실제 구현은 어떤 모듈이든 단 하나만 존재해야 함.
    - 링커는 이를 찾아내 연결 (심벌 해석 symbol resolution)
- 재배치 relocation
    - 참조한 곳의 주소를 임의로 표시했다가, 최종적인 작업에 들어가야 정확한 주소 표현 가능.
    - 이때 임의로 표시된 부분을 전부 수정하는 과정
- 링커가 알아야 하는 정보
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6ac5d8a4-16ad-4cf8-84bb-2f89d8c04c9a/535019a7-2dc8-4324-a663-12a8cd351e9c/Untitled.png)
    
    - 전역 변수 (소스 파일에 존재하는, 다른 모듈에서 참조할 수 있는 심벌)
    - 참조하고 있는 변수 (소스 파일이 참조하고 있는 다른 모듈에서 정의한 심벌)

### 1.4 컴퓨터 과학에서 추상화가 중요한 이유
- 복잡도 제어
- 객체 지향 언어
    - 다형성
    - 추상 클래스
- 저급 언어 대신 고급 언어를 사용하여 CPU를 제어할 수 있는 것은 추상화가 일어났기 때문이다.
- 프로그램은 프로세스로 추상화
- 물리 메모리와 파일은 가상 메모리로 추상화
- 네트워크 프로그래밍은 소켓으로 추상화
- 프로세스와 프로세스에 종속적인 실행 환경은 컨테이너로 추상화
- CPU, 운영 체제, 응용 프로그램은 가상 머신으로 packaging 되어 추상화
- 추상화를 통해 저수준 계층을 몰라도 다루는 것에는 문제가 없지만, 추상화 계층을 넘어서거나 본인만의 것을 만들기 위해서는 저수준 계층을 이해할 필요가 있다. 
