## Section 4.1 이 작은 장난감을 CPU라 부른다.
> 개발자가 아무리 복잡한 코드를 만들어도 최종적으로는 트랜지스터의 간단한 개폐 작업으로 이뤄진다.

~~고맙습니다 조지 부울 경~~

트랜지스터 조합으로 만들수 있는 기본 논리회로
- 논리곱(AND) : 1 1 = 1 / 1 0 = 0 / 0 1 = 0 / 0 0 = 0
- 논리합(OR) :  1 1 = 1 / 1 0 = 1 / 0 1 = 1 / 0 0 = 0
- 논리부정(NOT) : 0 = 1 / 1 = 0

기본 논리 게이트로 모든 논리함수를 표현할수 있음 = 논리적 완결성(Logical Completenes)

CPU가 Program Counter를 어떻게 증가시킬까 -> 가산기를 쓰면 되지 않을까.

CPU가 어떻게 함수 리턴 포인터를 기억하게 할까 -> 부정 논리곱 게이트를 조합한 저장장치를 쓰면 되지 않을까.

논리회로의 조합으로 다양한 프로그램을 구동하는 범용연산장치 = 컴퓨터

컴퓨터내부의 CPU가 어떤 명령을 수행할수 있는지는 명령어 집합을 제공하여 해결한다. -> 그런 의미에서 추가해보는 [Intel 8080 opcode](https://pastraiser.com/cpu/i8080/i8080_opcodes.html)
저걸 어떻게 써먹는건지 궁금하면 [예제](#op-code-sample)로

> 명령어 집합(instruction set) = 명령어(opcode) + 피연산자(operand)

> CPU내부에 존재하는 다양한 회로들이 상호작용할수 있게 지휘자의 역할을 하고 있는것이 클럭 신호

걍 이해하기 쉽게 한클럭마다 하나의 operation이 일어난다고 생각하면 됨.

클럭스피드가 빠르다 -> 연산엔진소리 죽이는데

산술논리장치 + 레지스터 + 클럭 = CPU

## Section 4.2 CPU는 유휴상태일때 무엇을 할까

대부분의 시간을 운영체제의 프로세스를 처리한다. 그리고 운영체제는 자신이 만든 프로세스 + 사용자의 프로세스들을 스케줄링한다.

그러나 시스템에 할일이 남아있지 않다면 System Idle Process를 실행한다. -> 실제로 컴퓨팅 자원을 소모하지는 않는 가상 프로세스.

유휴상태를 빠져나올때는 인터럽트라는것을 쓰더라 -> Dos 시절 프로그래밍할때 키보드 인터럽트, 사운드 인터럽트가 있었음. 아마 [그거](#interrupt)일까?

## Section 4.3 CPU는 숫자를 어떻게 인식할까?

CPU는 정수값을 표현할때 부호 비트를 이용해 양/음의 정수를 표현한다.(signed/unsigned 생각해볼것)

부호비트를 사용하지 않을땐 보수를 사용할수도 있다.

예: 0101 = 5 / 1010 = -5

그리고 실제 연산을 할때는 보수를 응용해서 연산함.

## Section 4.4 CPU가 if 문을 만났을때

CPU가 기계 명령어를 실행하는 곳은 공장에서 차량을 생산하는것과 다르지 않다 : 명령어 인출 -> 명령어 해독 -> 실행 -> 다시쓰기

CPU가 if문을 만나면 분기 점프를 해야 하는데, 어디로 점프해야 할지를 예상하게 된다. 그리고 이 예상이 실패하면 분기 실패로 인한 CPU 타임을 손실하게 된다. -> 조건문이 컴퓨팅 자원 생각보다 많이 까먹기 때문에 이부분 코딩을 잘해야 함. 특히 if 문 지저분하게 중첩되어 있는 구조라거나.

## Section 4.5 CPU 코어수와 스레드 수 사이의 관계는 무엇일까

결론: 아무 상관없음.

다만 스레드가 많다고 해서 단일이든 다중이든 다 좋은건 아니니 이점 잘 판단할것.

## Section 4.6 CPU 진화론(상): 복잡 명령어의 탄생

개발자 눈에는 하나의 프로그램이 실행되는 것이지만, CPU 입장에서는 수많은 명령어 집합들이 실행되는것.

그리고 CPU의 능력은 명령어 집합들에 달려있다.

단일 복잡 명령어 : 여러 단순명령어를 실행하기 위한 도구

왜 이게 필요하냐면
- 프로그래머가 작성한 연산 코드와 CPU 명령어의 간극을 줄이고(추상화)
- 메모리 공간을 절약하는데 좋다

## Section 4.7 CPU 진화론(중): 축소 명령어의 탄생

컴파일러로 인해 프로그래머가 직접 어셈블리어를 다룰 필요가 줄어듬.

축소 명령은 명렁어들의 파이프라인 구조를 기반으로 한다. -> 리눅스의 파이프라인과 비슷한건가?

## Section 4.8 CPU 진화론(하): 절체절명의 위기에서 반격

복잡 명령어를 축소 명령어처럼 작동시키기 위해 인터페이스를 끼워 넣음.

## Section 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기.

- 레지스터 : 속도 때문에 필요함. CPU 밖에 CPU를 위한 저장공간을 둔다면 속도가 매우 느려질것.
- 스택 포인터: CPU가 함수 실행을 하기 위해 다른 메모리 공간으로 넘어갔을때 돌아오기 위해 필요
- 명령어 주소 레지스터: 실행을 위한 명령어가 있는 메모리 주소
- 상태 레지스터: CPU 연산 상태를 기록

---
# OP Code Sample

### 8080 명령어 예제: 두 숫자 더하기 ➕

제공된 웹페이지 `pastraiser.com`의 8080 명령어 표를 기반으로 간단한 예제 프로그램을 구성하고 설명해 드리겠습니다. 이 프로그램은 두 개의 숫자를 **8080 CPU**의 레지스터에 각각 저장한 후, 이를 더하는 간단한 연산을 수행합니다.

-----

### 예제 프로그램: 30(H) + 20(H)

```assembly
; 예제: 레지스터 B에 있는 값(20H)을 레지스터 A에 있는 값(30H)과 더하기

      ORG 0000H         ; 프로그램 시작 주소를 0000H로 설정

      MVI A, 30H        ; 명령어: MVI (Move Immediate)
                        ; 30H(16진수) 값을 레지스터 A(Accumulator)에 즉시 로드합니다.
                        ; 이제 A 레지스터에는 30H 값이 저장됩니다.

      MVI B, 20H        ; 명령어: MVI (Move Immediate)
                        ; 20H(16진수) 값을 레지스터 B에 즉시 로드합니다.
                        ; 이제 B 레지스터에는 20H 값이 저장됩니다.

      ADD B             ; 명령어: ADD (Add)
                        ; 레지스터 B의 값(20H)을 레지스터 A의 값(30H)에 더합니다.
                        ; 결과는 A 레지스터에 저장됩니다. (A = A + B)
                        ; 즉, A = 30H + 20H = 50H가 됩니다.

      HLT               ; 명령어: HLT (Halt)
                        ; CPU를 정지시킵니다. 프로그램 실행을 종료합니다.
```

-----

### 예제 설명 📝

이 예제는 8080의 기본 명령어들을 활용하여 다음과 같은 흐름으로 동작합니다.

1.  **시작 주소 설정**: `ORG 0000H`는 프로그램이 메모리의 0000H번지부터 시작한다는 것을 의미합니다.

2.  **데이터 로드**: `MVI A, 30H`와 `MVI B, 20H`는 **MVI(Move Immediate)** 명령어를 사용하여 두 개의 즉치 값(immediate value)을 각각 A와 B 레지스터에 저장합니다. MVI 명령어는 op code 테이블에서 **"06"**, **"0E"**, **"16"**, **"1E"**, **"26"**, **"2E"** 등으로 나타납니다.

3.  **덧셈 연산**: `ADD B`는 **ADD(Add)** 명령어로, 레지스터 A와 B의 값을 더합니다. 이 명령어는 \*\*"80"\*\*으로 시작하는 다양한 op code 중 하나입니다. 결과는 항상 **A(Accumulator)** 레지스터에 저장됩니다.

4.  **프로그램 종료**: `HLT`는 **HLT(Halt)** 명령어로, CPU의 동작을 멈춥니다. 이 명령어의 op code는 \*\*"76"\*\*입니다. 이 명령어가 없으면 프로그램은 다음 메모리 주소로 계속 진행되어 예상치 못한 동작을 일으킬 수 있습니다.

이 예제는 8080 명령어 세트의 핵심적인 기능인 **데이터 전송** (`MVI`)과 **산술 연산** (`ADD`)을 보여주며, 간단한 프로그램을 통해 CPU가 어떻게 명령어를 순차적으로 처리하는지 이해할 수 있도록 돕습니다.

# Interrupt

키보드, 사운드 등 DOS의 하드웨어 인터럽트와 CPU의 타이머 인터럽트는 둘 다 **인터럽트**라는 큰 범주에 속하지만, 그 **발생 원인과 용도**는 다릅니다.

### 공통점: 인터럽트의 기본 원리
둘 다 **현재 CPU가 수행 중인 작업을 일시적으로 중단**시키고, 미리 정의된 **인터럽트 핸들러(interrupt handler)** 루틴으로 CPU의 제어를 옮긴다는 점에서 같습니다. 인터럽트 핸들러는 특정 이벤트에 대한 처리를 담당한 후, 원래 중단되었던 작업으로 복귀합니다. 

***

### 차이점: 발생 원인과 목적

#### 1. 하드웨어 인터럽트 (키보드, 사운드)
* **발생 원인**: 키보드 입력, 마우스 움직임, 사운드 카드에서 데이터 재생 완료 등 **외부 장치**의 물리적인 이벤트에 의해 발생합니다.
* **목적**: CPU가 외부 장치의 변화를 항상 감시할 필요 없이, 이벤트가 발생할 때만 즉각적으로 대응하기 위함입니다. 이를 통해 CPU는 다른 작업을 효율적으로 수행할 수 있습니다. 예를 들어, 키보드 인터럽트는 사용자가 키를 누를 때 발생하여, CPU가 키 입력을 처리하는 루틴으로 넘어가게 합니다.

#### 2. 타이머 인터럽트 (CPU의 타이머)
* **발생 원인**: CPU 내부의 **타이머 회로**가 미리 설정된 시간 간격(예: 1초에 100번)마다 주기적으로 발생시킵니다.
* **목적**: 운영체제가 **멀티태스킹**을 구현하는 데 핵심적인 역할을 합니다. 타이머 인터럽트가 발생하면 운영체제는 현재 실행 중인 프로세스를 중단하고, 다른 프로세스에게 CPU 사용 시간을 할당합니다. 이 과정을 통해 여러 프로그램이 동시에 실행되는 것처럼 보이게 만듭니다.

### 요약
| 구분 | 하드웨어 인터럽트 (키보드, 사운드) | 타이머 인터럽트 (CPU 타이머) |
|:---|:---|:---|
| **발생 원인** | 외부 장치의 물리적 이벤트 | CPU 내부 타이머의 주기적인 신호 |
| **주요 목적** | 외부 장치 이벤트에 대한 즉각적인 반응 | 운영체제의 멀티태스킹 구현 및 스케줄링 |

따라서 키보드나 사운드 인터럽트와 CPU의 타이머 인터럽트는 컴퓨터 시스템의 효율적인 작동을 위한 필수적인 요소이지만, 그 역할과 목적은 명확히 구분됩니다.