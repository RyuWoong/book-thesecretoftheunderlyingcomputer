## Chapter 1

> 프로그래밍 언어는 컴퓨터 과학의 매우 작은 부분에 불과하다
 -> 언어는 컴퓨터에 명령을 내리는 도구에 불과하기 때문.

> 프로그래밍 언어를 깊이 이해하는 가장 좋은 방법은 프로그래밍 언어를 직접 새로 만들어 보는 것이다

```
만약 내가 프로그래밍 언어를 새로 만들어야 한다면, 만들어야 할것들
- 구문 분석기
- 토큰 파서
- 컴파일러
- I/O 드라이버(또는 인터페이스)
```

### Section 1.1 여러분이 프로그래밍 언어를 발명한다면?

> CPU는 단세포 생물처럼 매우 원시적이라, 데이터를 옮기고 연산하고 저장하는 것밖에 모른다.

```
어셈블리어 수업때 들은거 같은데, 가장 많이 보였던게 mov, add, jmp 같은 거였던듯.
```

프로그래밍 언어의 발전

기계어(2진수) -> 어셈블리

어셈블리 + 구문(syntax) = 사람이 이해할수 있는 프로그래밍 언어

구문 tree -> 기계어로 번역해 주는 도구 => 컴파일러

### Section 1.2 컴파일러는 어떻게 작동하는 것일까?

컴파일러 : 고수준 언어를 저수준 언어로 번역해준다.

컴파일러가 하는 일

1. 소스코드를 토큰 단위로 분해한다
    1. 이 과정에서 문법적 오류를 검사함
2. 토큰을 구문 트리(syntax tree)로 만든다.
3. 구문 트리를 의미분석 한다
4. 구문 트리를 중간코드로 변환한다(컴파일러에 따라 건너 뛸 수도 있음)
5. 중간 코드를 어셈블리어로 번역한다.
6. 어셈블리어로 번역된 코드를 기계어로 변환한다.

이렇게 만들어진 기계어 뭉치들을 실행가능한 하나의 단위로 만드는 것 -> 링커(linker)

### Section 1.3 링커의 말할수 없는 비밀.

기계어로 번역하는 과정에서 만들어지는 외부 심볼들을 실제 대상(함수라거나)으로 변환해준다.

컴파일러는 코드를 변환할때 데이터 영역과 코드 영역으로 나눈다.

나누는 작업을 할때 링커를 위해 외부 심볼 정보를 기록하는 심볼 테이블을 만든다.

최종적으로

| Data         |
|--------------|
| Code         |
| Symbol Table |

- 정적 라이브러리: 내코드 컴파일할때 같이 컴파일됨.
- 동적 라이브러리: 내 코드 돌리는데 필요한 필수 정보(라이브러리 이름, 심벌 테이블, 재배치정보)만 들어감

동적 라이브러리를 쓰면,
- 배포판에 모든 라이브러리 코드가 없어도 되고
- 라이브러리만 따로 배포해서 버전업 할수 있고
- 기본적인 코드 언어의 한계를 뛰어넘는 라이브러리를 만들어 가져다 쓸수 있고
- 다만 참조를 할때 절대주소를 쓸수 없으니 호출 속도는 좀 떨어진다. ~~그게 티가 날까~~

그리고 링커는 이런 변수나 함수의 메모리 주소를 런타임시 어디를 쓸지 주소를 결정한다.
~~근데 여기서 가상 메모리가 나올줄은 몰랐는데~~

운영체제 관점에서의 가상 메모리는 아니고, 운영체제가 프로세스 관점에서 할당해준 메모리 공간.
프로세스는 이를 메모리 테이블로 관리한다.

### Section 1.4 컴퓨터 과학에서 추상화가 중요한 이유

프로그래밍 언어 : 추상화를 통해 내부의 복잡한 구현에 대해 몰라도 코딩할수 있고, 확장할수 있다.(추상화 계층에서의 인터페이스만 일치시키면 되니까?)

| 실체 | 추상화 |
|------|------|
|CPU(트랜지스터 덩어리)| 명령어 집합|
|입출력 | 파일 |
|프로그램 | 프로세스 |
|물리 메모리와 파일 | 가상 메모리|
|네트워크 자원| 소켓|
|실행환경| 컨테이너|

### Section 1.5 요약

사람이 알아먹기 쉽게 만들어진 코드는 그 자체로 추상화된 개념이며, 이 추상화된 개념은 역시 추상화된 개념의 컴퓨터가 받아들여 그 실체로 작동하게 한다.

