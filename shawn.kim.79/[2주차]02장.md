## Chapter 2. 프로그램이 실행되었지만 뭐가 뭔지 하나도 모르겠다

~~그거 니가 C언어 안해서 그래~~

### Section 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

모든것은 CPU에서 시작한다
> CPU는 단지 두가지 사항만 알고있다
> 1. 메모리에서 명령어를 하나 가져온다
> 2. 명령어를 실행하고 1로 돌아간다

프로그램 카운터라는 레지스터라는 메모리에서 명령어의 주소를 가져온다.

그럼 그 주소에는 물리적 메모리의 주소가 있을거다

물리적 메모리에는 컴파일러가 만든 프로그램 코드가 있을거다

그러니까 운영체제도 프로그램이라는 소리

**프로그램 로딩(간략 버전)**

프로그램을 적재할수 있는 메모리 영역을 찾는다 -> CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC 레지스터를 설정한다.
~~참쉽죠?~~

이방법의 단점
- 한번에 하나의 프로그램만 실행할수 있다(DOS 생각해보자. config.sys에 SYSMEM 설정이 왜 있었을까? 프로그램 끝나면 운영체제로 돌아가기 위해서 아니었을까?)
- 모든 프로그램은 사용할 하드웨어와 드라이버를 직접 연결해야 한다.
- 입출력도 다 처리할수 있게 만들어야 한다.
- UI도 다 직접 그려야 한다.
~~여기까지 쓰니까 PDP-8이 생각난다~~

한번에 여러 프로그램 돌릴라면 각각의 프로그램을 잠깐 정지했다가 돌렸다를 반복하면 된다.

잠깐 정지하는 순간까지의 프로그램 상태를 Context라고 한다.

그리고 Context에 기록되는 정보를 단위로 묶으면 Process가 된다.

```
DOS보다 이전에, 리눅스보다 이전에, 유닉스가 멀티태스킹이 되었던 것은 애초부터 다중사용자를 상정하고 만들었기 때문
```

따라서 운영체제는 프로세스를 관리하면 되는것.

여러 프로세스가 묶여서 하나의 작업단위를 처리할때(다중 프로세스 프로그래밍), 이 방법의 단점
- 프로세스 생성할때마다 시스템 자원을 잡아먹는다(CPU와 운영체제가 관리할 거리가 늘어난다)
- 프로세스 마다 자체적은 주소공간을 소유하기에 프로세스간 통신은 코딩하기 복잡하다

~~그래서 파이프가 위대한것~~

프로세스에서 스레드로
스레드 : 하나의 프로그램에 진입점을 복수개로 두는것

```
이건 설명이 좀 이상한데?
차라리 "하나의 프로세스가 자신에게 할당받은 메모리 공간 내 존재하는 명령어를 직접 실행시키도록 운영체제가 제공하는 명령어로 감싸서 실행시킨다"이라는 표현이 맞지 않나? 
```

따라서 스레드를 돌리면 스레드 컨텍스트를 위해 메모리 공간도 소모된다. -> 이 과정에서 컴퓨팅 자원을 소모하게 되니 스레드 풀을 쓰는 것이다.

스레드 풀 사이즈를 정확하게 만들려면 각 스레드들이 CPU 자원을 얼마나 소모하는지 계산해야 한다
~~이거 웬지 게임엔진 최적화 이야기하고 비슷한거 같다~~

스레드가
- 계산만 할때 : CPU 자원만 쓰기 때문에 판단하기 쉬움
- I/O를 처리할때: Wait time + Computing time을 생각해야 한다.(그래서 ISA보다 PCI가 빠르고 PCI보다 PCIe가 빠르고 빠를수록 좋은게 그래서 그런것)

### Section 2.2 스레드간 공유되는 프로세스 리소스
스레드에 속한 스택 영역 + 프로그램 카운터 + 스택 포인터 + 스레드를 위한 레지스터 정보 = 스레드 컨텍스트

스레드는 프로세스 주소공간에서 스택 영역을 제외한 나머지 영역을 모두 공유한다 -> 왜 스택영역을 제외할까? 그랬다간 프로그램 실행이 꼬이겠지?

스레드는 프로세스 내의 데이터 영역을 공유한다. -> 그래서 메모리 할당 잘못하면 난리나는것.

스레드는 다른 스레드의 스택 프레임의 포인터를 가져와 그 값을 변경할수 있다 -> ~~응 돼도 하지마~~

또한 동적 라이브러리에게 할당된 영역도 공유한다.

```
이 섹션에 있는 코드는 전부 C++로 작성된 코드인데, 그 언어로 작성된 이유가 있는거 같다...

```
~~왜긴왜야 메모리 곡예 보여줄라고 그러지~~

### Section 2.3 스레드 안전코드는 도대체 어떻게 작성해야 할까?

하나만 기억하자: 공유 리소스를 사용할 경우에는 다른 스레드에 영향을 주지 않도록 하자. -> 공유 리소스의 범위 : 프로세스 내 데이터 부터 I/O까지 모든 컴퓨팅 자원.

영향을 주지 않게 하는 방법 -> 스레드끼리 방해하지 않게 잠금하거나 세마포어를 쓴다.
- 스레드 전용 저장소를 쓴다: 스레드끼리 격리시킨다~~근데 그럴거면 스레드 왜쓰냐~~
- 읽기 전용
- 원자성 연산: std::atomic
- 동기화 시 상호배제 : mutex + lock

### Section 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?
- 일반함수: 함수 중간에 return이 있음면 그 함수는 즉시 중단된다.
- 코루틴: 함수 중간에 return이 있으면 그상태에서 반환하고 일시 중단. 다시 호출하면 중단점부터 다시 시작.

추가 궁금점: 코루틴 실행시, 한번 호출이 끝나고 다음번 호출할때 새로 인자를 주면 어떻게 될까? -> 답: 새로 주어진 인자가 재시작점에 주입된다.

```
파이썬 기준으로 코루틴 일시 정지시에는 yield를 쓴다.
```
```python
# 이 코드도 이해해두자
def my_coroutine():
    print("코루틴 시작. 초기 인자:", (yield))
    while True:
        value = (yield)
        print("재호출. 전달된 값:", value)

# 코루틴 생성
co = my_coroutine()

# 첫 호출: 초기 인자 전달
next(co) # 또는 co.send(None)
# 출력: 코루틴 시작. 초기 인자: None

# 재호출: 새로운 값 전달
co.send("Hello")
# 출력: 재호출. 전달된 값: Hello

# 또 다른 재호출
co.send(123)
# 출력: 재호출. 전달된 값: 123
```

### Section 2.5 콜백함수를 철저하게 이해한다.