인류의 창의성으로 0과 1밖에 저장 못하는 메모리에 만들어 낸 개념
- 힙/스택/데이터
- 가상메모리
- 메모리 할당 / 해제 / 누수

> 프로그래밍 언어의 우열에 대해서 격렬한 토론을 하는 프로그래머들도 메모리에 대해서는 만장일치로 단결한다.

-> 그러니까 뭐로?

### Section 3.1 메모리의 본질, 포인터와 참조

**메모리 공부를 할때 착각하기 쉬운 것**
```
컴퓨터는 알고있어야 할 모든 것을 메모리에 기록한다. 여기서 "알고있어야 할 것"의 범주는, 개발자가 명시적으로 알고 있으라고 한것(변수라거나)도 있고 프로그램 실행중에 알아둬야 할것(동적으로 할당한 메모리 공간의 시작 주소라거나)도 있다. 좀 골치 아픈건, 이런것들이 한데 뒤섞여서 하나의 메모리라는 공간에 들어가다 보니 여기서 개념 착각을 잘 일으킨다.
```

> C언어와 같은 프로그래밍 언어에서 int형 변수가 4byte인 이유 -> CPU 처리방식 때문임. 과거 16비트 컴퓨터 시절에는 16비트 레지스터 두개로 메모리 주소를 제어함. 그래서 int형 사이즈도 16비트(2바이트)였던거고.

> 포인터는 메모리 주소를 더 높은 수준으로 추상화한것.

~~참조(reference)가 이 이야기 들으면 섭섭해 하겠는데~~

간접 주소 지정 : 메모리 주소에 저장된 값도 다른 메모리 주소로 간주하여, 해당 주소까지 찾아가서 실제 값을 알아내는것.

```
이 구조가 주는 의미는 매우 심오한데, 
1. 동적 메모리 할당이 가능한 원리이며,
2. 데이터 구조에서 차원수 확장을 가능하게 해주는 요인이다.(ex. 배열의 배열의 배열 -> 포인터의 포인터가 가르키는 배열) 
```

### Section 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

메모리 내 프로세스 구조를 다 그릴필요는 없고, 메모리와 관련된 이야기만 하자면 스택은 함수 실행시 필요한 정보, 힙은 동적 메모리 할당 영역이다 -> 디버깅 트레이스할때 함수 콜 스택이라는 말은 많이 봤을것!

실질적으로 프로세스가 알고 있는 메모리 주소도 전부 가상 메모리 주소 -> 운영체제가 따다 주는것이라 생각하면 됨. 실제로 어디 처박혀 있는지는 아무도 모른다. 그래서 메모리 단편화(파편화)가 늘 GC이야기할때 한번은 나오는 주제가 된다.

### Section 3.3 스택영역: 함수 호출은 어떻게 구현될까?

~~참고로 이 섹션 시작에 보이는 코드를 실제로 작성한다면 매우 높은 확률로 불호령을 듣습니다~~

> 함수는 가장 기초적이고 간단한 코드 재사용 방식입니다.

> 함수가 어떻게 구현되어 있는지는 신경쓸 필요가 없으며, 이 역시 일종의 추상화에 해당합니다.

```
아쉽지만 그 내부가 어떻게 구현되어 있는지 100% 신경쓸 일이 없다고 보장할수는 없다.
```

함수 호출 구조는 이진트리의 순회 탐색구조와 유사함.
```
이러한 순회 탐색구조의 근본적인 원인은 함수 호출의 의존성이 원인이라 할수 있겠다.
그렇다면 의존성이 있는 코드를 스레드로 돌리는것 자체가 위험성을 내포하고 있다 할수 있지 않을까?
함수 호출로 인한 의존성을 끊어내는게 좋은 코드 구조 아닐까?
```
~~뭔 당연한 소리를 그렇게~~

```
함수 호출할때마다 메모리 공간을 잡아먹는다는 사실은 기억해둘 필요가 있다.
하지만 메모리 사이즈가 매우 커진 현대 컴퓨터 시스템에서 이게 진짜로 큰 이슈가 될까에 대해서는 재고의 여지가 있다.
오히려 동적 메모리 할당에 더 주의해야 하지 않을까?
```

### 3.4 힙 영역: 메모리의 동적할당은 어떻게 구현될까?

함수가 ~~처묵처묵~~ 사용하는 영역(스택 프레임) = 반환주소 + 함수 지역변수 + 매개변수(Parameter) + 사용되는 레지스터

함수 호출이 끝나면 바로 반환된다.

> 그러므로 주의해야 할것
>> 스택 프레임에 저장된 내용은 더이상 사용하지 않으니 지역변수 데이터에 대한 포인터를 반환해서는 안됨 ~~이거 C에서 많이 해먹는 수법인데~~
>> 지역 변수의 수명 주기는 함수 호출과 동일.

데이터 생명주기가 여러 함수에 걸쳐 있을때 필요한 데이터 저장공간 = 힙

힙에 데이터 공간을 할당할때는 malloc(c), new(c++). 해제할때는 free(c), delete(c++).

```
malloc은 안그런데 delete는 아마 메모리 공간 내 데이터 초기화까지 시켜주던가.
```

malloc은 linked list를 이용해서 메모리를 할당한다.
``` 
조각들을 연결해서 목표로 하는 할당 공간을 만들어 낸다는것. 그래서 메모리 할당/해제시 늘 컴퓨팅 자원 비용이 들어감.
이와달리 배열은 linear하게 할당됨.
*p = malloc(sizeof(int)*10); 보다 *p = &int[10];이 더 빠를수 있다는것. 다만 후자쪽은 정적이므로 함수 나가면 데이터가 사라짐. 그래서 실제로 함수 시작은 후자처럼 일단 선언 했다가 모든 처리가 끝난 함수 최종단계에 큰 버퍼 하나 잡고 memcpy해서 반환하는 일도 했던듯 ~~가물가물~~.

```

### 3.5 메모리를 할당할때 저수준 계층에서 일어나는 일

운영체제의 코드를 CPU가 실행할 때 : 커널 상태

프로그래머가 작성한 코드를 CPU가 실행할때 : 사용자 상태

프로그래머가 작성한 코드는 특정 메모리 위치에 접근할수 없다. 
```
여기서 책에는 운영체제의 메모리 영역에 사용자 프로그램이 접근하는 것을 세그먼테이션 오류라 했는데 정확히는 세그먼테이션 위반이 아닐까 싶다.
```

사용자 코드가 직접적으로 운영체제의 시스템 콜을 이용하는 것보다, 표준라이브러리를 이용해 한계층 덧씌우는 것이
- 안전성과
- 시스템 호환성면에서

좋다고 할수 있겠다.

만약 힙 메모리에서 메모리를 할당하는데 프로세스에게 할당된 영역이 부족하면 시스템 호출을 통해 확장한다. -> 다시말해 메모리 할당할때 사용자 상태와 커널상태를 왔다갔다 할수 있다는것. 
```
동적 메모리할당이 편리하지만 컴퓨팅 자원을 소모하는 원인이 여기 있지 않을까?
```

### 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

메모리 풀 - 매번 운영체제에 공간달라고 할거 없이 한번에 왕창 크게 떼온다음 내 편한대로 쓰는것.

스레드 세이프한 동작을 만들려면, 메모리 풀 하나를 쓰지 말고 스레드마다 메모리 풀을 할당하는게 좋다.
~~메모리 공간 퍼먹을텐데 그럼~~

Q. 하나의 스레드가 메모리 조각을 사용하고 종료 되었는데, 그 메모리 조각은 다른 스레드에서도 사용하고 있다면?

A.

  1. 메모리 할당 후 스레드에서 접근할때마다 메모리 조각의 참조 카운터를 증가시킨다.
  2. 각 스레드가 종료될때마다 참조 카운터를 감소시킨다.
  3. 메모리 풀 관리자는 별도의 스레드로 작동하며, 참조 카운터가 0인 메모리 공간을 찾아 할당을 해제한다.

```
근데 생각해보면 메모리 풀 관리자 자체가 메모리에 대한 접근 통제까지 다 하는게 좋지 않나?
```

### 3.7 대표적인 메모리 관리 버그

- 지역변수의 포인터 반환 -> 얘는 약간 운빨요소가 있음. 과거에는 반환해도 메모리 영역이 살아있기 때문에(무언가로 덮어 쓰여지지 않았기 때문에) 당장은 작동에 이상이 없어보일때가 있음.
- 포인터 연산의 잘못된 이해. 포인터는 자동적으로 할당된 데이터 타입만큼 옵셋을 가진다. -> 근데 이거 배열에나 먹히는 이야기일걸?
- 문제 있는 포인터 역참조 -> 주로 변수의 참조를 받아야 하는데 거기에 값이 있는 변수 던져줄때. 
- 초기화되지 않은 메모리 읽기
- 이미 해제된 메모리 참조하기
- 오버플로 또는 잘못된 옵셋값
- 메모리 누수 -> 이게 제일 골치아프다

### 3.8 SSD는 왜 메모리로 사용할수 없을까?
한줄요약 : SSD는 바이트 단위로 관리하지 않고 파일 시스템(아마도 파티션?)단위로 관리한다.