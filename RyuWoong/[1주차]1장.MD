# 1.1 여러분이 프로그래밍 언어를 발명한다면?

## 요약

- 초기 CPU는 기계어만 이해해 인간이 사용하기 어려웠다.
- 어셈블리어와 고급 언어는 인간의 추상적 명령을 CPU가 이해할 수 있는 명령으로 자동 변환하기 위해 발명되었다.
- 반복적/규칙적 명령은 **재귀 구조와 구문 트리(AST)**로 표현되어 컴파일러/인터프리터가 효율적으로 처리할 수 있다.

## 이론 정리

- 초기 CPU → 기계어(1101 등)만 처리 가능, 불편함
- 어셈블리어 → 인간 친화적 명령(add, sub, mov 등)
- 고급 언어 → 추상적 명령을 규칙/패턴 기반으로 기계 명령어로 변환
- 반복적/규칙적 명령 → 재귀 구조 활용 가능
- 코드 구문은 **구문 트리(AST)**로 분해 가능 → 노드 단위로 명령과 연산 표현
- AST를 재귀적으로 순회하며 컴파일러/인터프리터가 명령을 기계어로 변환
- 시뮬레이션 프로그램(가상 머신) → CPU 명령어 이해 가능하게 추상화, 인터프리터처럼 한 줄씩 실행

## 사례/스토리 정리

- “물 한잔 주세요”라는 추상 명령 → 저수준 명령으로 구현하면 수많은 단계 필요
- 반복·규칙·매개변수 발견 → 복잡성을 줄이고 생산성 향상 가능
- AST로 표현하면 **반복, 조건, 함수 호출 등 구조적 관계가 트리로 나타나며**, 재귀적으로 처리 가능
- 가상 머신/인터프리터 → CPU마다 다른 명령어 문제 해결, 고급 언어 실행 가능

# 1.2 컴파일러는 어떻게 동작하는 것일까?

## 요약

- 컴파일러는 일반 프로그램으로, 인간이 작성한 추상적 표현을 CPU가 이해할 수 있는 기계어로 변환한다.
- 컴파일 과정에서 코드는 먼저 **토큰(Token)** 단위로 쪼개지고, **구문 트리(AST)** 구조로 분석된다.
- 이렇게 만들어진 AST를 기반으로 최적화와 기계어 코드 생성을 거쳐 CPU가 실행 가능하게 된다.

## 이론 정리

- **컴파일러 = 코드 번역 프로그램**: 고급 언어 → 기계어
- **렉싱(Lexing)**: 코드 문자열 → 토큰(token)으로 분리
- **파싱(Parsing)**: 토큰 → 구문 트리(AST)로 구조화
- **최적화(Optimization)**: 반복/조건/연산 구조를 효율적으로 변환
- **코드 생성(Code Generation)**: AST → CPU가 이해 가능한 기계어
- **재귀적** **처리**: 구문 트리 구조 덕분에 반복/규칙적 명령 효율적 처리

## 사례/스토리 정리

- 코드 x = 3 + 5 → 토큰 [x] [=] [3] [+] [5] → AST (= x (+ 3 5)) → 기계어 변환
- 조건문, 반복문, 함수 호출 등도 AST에서 **재귀 구조**로 표현되어 컴파일러가 순회하면서 처리
- 초기 CPU와 고유 명령어 문제 → 가상 머신/인터프리터로 추상화 가능

# 1.3 링커의 말할 수 없는 비밀

## 요약

- 링커는 여러 객체 파일을 하나의 실행 파일로 결합하고, 함수/변수 참조를 해결하는 중요한 역할을 한다.
- 심볼 테이블을 이용해 전역 변수와 함수 이름을 관리하고, 코드/데이터 영역의 주소를 결정한다.
- 가상 메모리 주소를 사용하고, OS가 페이지 테이블을 통해 실제 물리 메모리와 매핑하여 안전하게 실행할 수 있게 한다.

## 이론 정리

- 링커(Linker): 컴파일러가 생성한 객체 파일들을 하나로 연결
- 심볼(Symbol) & 심볼 테이블: 전역 변수, 함수 이름과 속성/주소 정보를 저장
- 주소 할당(Address Binding): 코드/데이터 영역에 심볼 주소 배치
- 가상 메모리 매핑: 링커가 할당한 가상 주소 → OS가 페이지 테이블 통해 실제 물리 메모리 매핑
- 정적/동적 라이브러리 연결
  - 정적: 컴파일 시 포함, 실행 파일 크기 증가, 독립적 실행 가능
  - 동적: 실행 시 로딩, 여러 프로그램 공유, 업데이트 용이

## 사례/스토리 정리

- 코드파일 -> 객체 파일 main.o, math.o, utils.o
  - 링커가 심볼 테이블 병합 → 주소 결정 → 라이브러리 연결
  - 결과: 하나의 실행 파일 생성 → CPU 실행
- 가상 메모리 예시:
  - x 가상 주소 0x1000 → OS가 물리 주소 0xA000 매핑 → CPU가 접근

# 1.4 컴퓨터 과학에서 추상화가 중요한 이유

## 요약

- 추상화 덕분에 우리는 기계 명령어, 메모리 주소, 하드웨어 제어 같은 세부 사항에 신경 쓰지 않고 프로그래밍할 수 있다.
- 파일, 프로세스, 가상 메모리, 소켓, 컨테이너 등 현실의 복잡한 시스템을 간단한 인터페이스로 감싸서 개발자가 효율적으로 활용 가능하게 한다.
- 하지만 자신만의 추상화 계층이나 최적화된 시스템을 만들려면 저수준 계층 이해가 필수적이다.

## 이론 정리

- 추상화 = 하드웨어·저수준 세부 사항을 사용자 친화적인 인터페이스로 감싸는 것
- 장점: 코드 단순화, 유지보수 용이, 다양한 환경에서 일관된 개발 가능
- 저수준 이해 = 자신만의 추상화 계층 설계, 최적화, 문제 해결 능력

## 사례/스토리 정리

- 입출력 장치 → 파일 API
- 프로그램 실행 → 프로세스
- 물리 메모리/디스크 → 가상 메모리
- 네트워크 장치 → 소켓 API
- 프로세스 실행 환경 → 컨테이너

# 1.5 요약

```
[사용자 코드 (고급 언어)]
       │
       ▼
[렉싱(Lexing)] → 코드 → 토큰(Token) 단위 분해
       │
       ▼
[파싱(Parsing)] → 구문 트리(AST, Abstract Syntax Tree) 생성
       │
       ▼
[최적화(Optimization)] → 반복/조건/연산 구조 효율화
       │
       ▼
[코드 생성] → 객체 파일(Object File) 생성
       │
       ▼
[링커(Linker)] → 여러 객체 파일 결합
       │     - 심볼 테이블 병합
       │     - 주소 할당(가상 주소)
       │     - 정적/동적 라이브러리 연결
       ▼
[운영체제(OS)] → 가상 메모리 → 페이지 테이블 → 실제 메모리 매핑
       │
       ▼
[실행 파일(Executable)] → CPU 실행
```
