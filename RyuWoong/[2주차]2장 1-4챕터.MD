# 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

### **1️⃣ CPU와 프로그램 실행**

- CPU는 매우 단순: **명령어를 Fetch → Decode → Execute → Update PC** 반복
- Program Counter(PC) 레지스터가 현재 실행할 명령어 위치를 가리킴
- 여러 프로그램을 동시에 돌리는 것처럼 보이게 하는 것은 **운영체제 스케줄러** 덕분

### **2️⃣ 운영체제(OS)의 역할**

- 하드웨어 위에서 **프로그램 실행 환경을 관리**
- 주요 기능:
  - 프로세스 관리 (멀티태스킹, 스케줄링, PCB 관리)
  - 메모리 관리 (주소 공간 분리, 가상/물리 메모리 매핑)
  - 파일 시스템 관리
  - I/O 장치 관리
  - 보호 및 보안

### **3️⃣ 프로세스**

- **실행 중인 프로그램 + 상태 + 자원** 묶음
- 메모리 구조:
  - 코드 영역 (Text) → 프로그램 명령어
  - 데이터 영역 (Data) → 전역/정적 변수
  - 힙 영역 (Heap) → 동적 메모리
  - 스택 영역 (Stack) → 함수 호출, 지역 변수, 리턴 주소
- 컨텍스트(Context, PCB)에 실행 상태 저장 → 컨텍스트 스위칭으로 멀티태스킹 구현

### **4️⃣ 스레드**

- **프로세스 안에서 실행 흐름 단위**
- 메모리 공유: 코드, 데이터, 힙
- 독립 스택: 각 스레드가 함수 호출/지역 변수 사용
- 장점: 오버헤드 적고, 통신이 용이
- 단점: 동기화 문제 발생 가능

### **5️⃣ 스레드풀(Thread Pool)**

- 미리 생성된 스레드 풀에서 작업 할당 → 스레드 재사용
- 장점:
  - 스레드 생성 비용 절감
  - 시스템 자원 효율적 관리
  - 빠른 작업 응답
- 스레드풀 크기 결정:
  - CPU 바운드 작업 → 스레드 수 ≈ CPU 코어 수
  - I/O 바운드 작업 → 스레드 수 > CPU 코어 수 (대기 시간 고려)

# 2.2 스레드 간 공유되는 프로세스 리소스

### **1️⃣ 스레드의 메모리 구조**

| 영역        | 공유여부 | 설명                                              |
| ----------- | -------- | ------------------------------------------------- |
| 코드 영역   | 공유     | 모든 스레드가 같은 명령어 집합 실행               |
| 데이터 영역 | 공유     | 전역 변수, static 변수, 모든 스레드 접근 가능     |
| 힙 영역     | 공유     | 동적 메모리(malloc/new) 모든 스레드 접근 가능     |
| 스택 영역   | 독립     | 각 스레드 별 함수 호출, 지역 변수, 리턴 주소 저장 |

### **2️⃣ 동적 라이브러리(DLL/SO)와 스레드**

- 코드 영역: 여러 프로세스/스레드가 **공유 가능한 읽기 전용 메모리**
- 데이터 영역: 구현에 따라 **프로세스별 별도 공간** 할당 가능
- 장점: 여러 프로세스가 동일 코드 공유, 메모리 낭비 감소

### **3️⃣ 스레드 전용(thread-local) 데이터**

- 스레드마다 **독립적인 전역/정적 변수** 필요 시 사용
- C++ 예: thread_local int counter; 또는 GCC/Clang 확장 \_\_thread
- 저장 위치: 스택과 별도로 런타임/OS가 관리하는 스레드 전용 영역
- 특징: 다른 스레드와 공유하지 않고, 스레드 종료 시 자동 해제

# 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

### 1. **리소스 구분**

1. **스레드 전용 리소스**

   - 각 스레드마다 독립된 공간에서 사용하는 것
   - 예: 스택에 저장된 지역 변수, thread_local / \_\_thread 로 선언된 데이터
   - 동기화 불필요 (서로 침범하지 않음)

2. **공용 리소스**

   - 여러 스레드가 동시에 접근할 수 있는 것
   - 예: 힙 메모리의 공유 객체, 전역 변수, 싱글톤 객체, 파일 핸들
   - 동기화 필요 (mutex, spinlock, atomic 등)

3. **읽기 전용 리소스 (공유 가능)**

   - 코드 영역이나 const 데이터처럼 **변하지 않는 자원**
   - 여러 스레드가 동시에 읽어도 안전
   - 동기화 불필요 (단, 값이 변경될 가능성이 있으면 위험)

아래와 같은 경우 스레드의 스택영역에서 관리하며, 아래와 같은 코드는 또 무상태함수이다.
스레드 안전 코드이다.

```c
int func() {
	int a = 1;
	int b = 1;

	return a+b
}
```

매개 변수를 값으로 전달하는 경우라면 문제가 없지만, 포인터를 전달하면 상황이 달라진다.

```c
int func(int num) {

	num++

	return num
}


// 포인터 전달
int func(int* num) {

	++(*num)

	return *num*
}
```

전역 변수를 가리키는 이 상황도 스레드 안전이 아니다.

```c
int global_num = 1;

int func(int* num) {
	++(*num)

	return *num
}


void thread1() {
	func(&global_num)
}

void thread2() {
	func(&global_num)
}

```

그러면 각 스레드에서 동작한 값이 반영 되니.

스레드 안전이 아닌 코드를 호출할 때,

```c
int global_num = 0

int func() {
	++global_num

	return global_num;
}

int funcA() {
	mutex 1;
	l.lock()
	func()
	l.unlock()
}
```

**mutex(뮤텍스), lock(락)** 은 여러 스레드가 동시에 공용 리소스에 접근하는 걸 조율해주는 “교통신호등” 같은 장치

**1. Mutex (뮤텍스, Mutual Exclusion)**

- 뜻 그대로 “상호 배제”
- **하나의 스레드만 리소스를 사용할 수 있게 잠금(lock)을 거는 도구**
- 다른 스레드가 접근하려고 하면, **잠금이 풀릴 때까지 기다림**
- 예: 화장실에 문을 잠그고 쓰는 것 → 한 명이 끝내고 문을 열어야 다른 사람이 들어갈 수 있음

**2. Lock (락)**

- 뮤텍스를 사용할 때의 **사용 방식** 또는 **개념적 추상화**
- lock() → 리소스 사용권 얻음
- unlock() → 리소스 사용권 반환
- 언어나 라이브러리에 따라 lock_guard, synchronized, ReentrantLock 같은 **락 관리 도구**가 제공됨

**3. Spinlock (스핀락, 가벼운 뮤텍스)**

- 뮤텍스랑 비슷하지만, 기다릴 때 **멍하니 잠드는 대신 계속 확인(바쁘게 루프)**
- 짧은 시간 안에 잠금이 풀릴 때 유리 (성능↑)
- 오래 걸리면 CPU 낭비 (성능↓)

### 2. **원자성(Atomicity)**

    - 공유 데이터를 여러 스레드가 동시에 접근할 수밖에 없다면, 최소한 **값이 깨지지 않도록 보장**해야 함.

    - 예: x++ 같은 연산은 사실 “읽기 → 더하기 → 쓰기” 세 단계라 원자적이지 않음 → atomic<int> 같은 걸 써야 안전.

### 3. **동기화 시 상호배제(Mutual Exclusion)**

    - 여러 스레드가 동시에 동일 리소스를 접근할 때, 반드시 한 스레드씩 차례로 접근하도록 막는 장치 필요.

    - 뮤텍스(mutex), 세마포어(semaphore), 락(lock) 등이 여기 해당.

# 2.4 프로그래머는 코루틴을 어떻게 이해해야할까?

JS 제네레이터랑 비슷해보여서, 제네레이터 기반으로 이해하는게 좋을 거 같다.

자바스크립트에서 제네레이터는 아래와 같이 작성하고 동작한다.

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();
console.log(g.next()); // { value: 1, done: false }
console.log(g.next()); // { value: 2, done: false }
console.log(g.next()); // { value: 3, done: false }
console.log(g.next()); // { value: undefined, done: true }
```

파이썬으로 작성한 코루틴은 아래와 같이 작성하고 동작한다.

```python
def coro():
    x = yield "start"
    yield f"got {x}"

c = coro()
print(next(c))     # "start"
print(c.send(42))  # "got 42"
```

코루틴은 제네레이터와 유사하게 멈출 수 있고, 이어 갈 수도 있지만, 다른 점은 데이터 흐름을 반영할 수 있다. `c.cend` 라는 것으로 값을 대입.

코루틴은 동기 방식으로 비동기 프로그래밍을 가능하게 해주는 핵심적인 역할은 한다.
